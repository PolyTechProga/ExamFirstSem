Описание списка

Пример описания списка
Type ukazat= ^ S;
   S= record
      Inf: integer;
      Next: ukazat;
   End;
В Паскале существует основное правило: перед использованием какого-либо объекта он должен быть описан. Исключение сделано лишь для указателей, которые могут ссылаться на еще не объявленный тип.

Формирование списка

Чтобы список существовал, надо определить указатель на его начало.

Пример описания списка
Type ukazat= ^S; 
   S= record 
      Inf: integer; 
      Next: ukazat; 
   End;


Создадим первый элемент списка:

New (u); {выделяем место в памяти}
u^. Next:= nil; {указатель пуст}
u^. Inf:=3;
Продолжим формирование списка. Для этого нужно добавить элемент либо в конец списка, либо в голову.

А) Добавим элемент в голову списка. Для этого необходимо выполнить последовательность действий:

получить память для нового элемента; поместить туда информацию; присоединить элемент к голове списка.
New(x); 
Readln(x^.Inf); 
x^. Next:= u; 
u:= x;
Б)Добавление элемента в конец списка. Для этого введем вспомогательную переменную, которая будет хранить адрес последнего элемента. Пусть это будет указатель с именем hv (хвост).

x:= hv;


New( x^. next); {выделяем память для следующего элемента}



x:= x^.next; 
x^.next:= nil; 
x^. inf:= 5; 
hv:=x;
Просмотр списка

While u<> nil do
Begin
Writeln (u^.inf);
u:= u^.next;>
end;
Удаление элемента из списка

А)Удаление первого элемента. Для этого во вспомогательном указателе запомним первый элемент, указатель на голову списка переключим на следующий элемент списка и освободим область динамической памяти, на которую указывает вспомогательный указатель.



x:= u; 
u:= u^.next; 
dispose(x);
Б) Удаление элемента из середины списка. Для этого нужно знать адреса удаляемого элемента и элемента, стоящего перед ним. Допустим, что digit – это значение удаляемого элемента.



x:= u; 
while ( x<> nil) and ( x^. inf<> digit) do 
begin 
dx:= x; 
x:= x^.next; 
end; 
dx:= x^.next: 
dispose(x);
В)Удаление из конца списка. Для этого нужно найти предпоследний элемент.

x:= u; dx:= u; 
while x^.next<> nil do 
begin 
dx:= x; x:= x^.next; 
end; 
dx^.next:= nil; 
dispose(x);
Прохождение списка. Важно уметь перебирать элементы списка, выполняя над ними какую-либо операцию. Пусть необходимо найти сумму элементов списка.

summa:= 0; 
x:= u; 
while x<> nil do 
begin 
summa:= summa+ x^.inf; 
x:= x^.next; 
end;
Динамические объекты сложной структуры

Использование однонаправленных списков при решении ряда задач может вызвать определенные трудности. Дело в том, что по однонаправленному списку можно двигаться только в одном направлении, от головы списка к последнему звену. Между тем нередко возникает необходимость произвести какую-либо операцию с элементом, предшествующим элементу с заданным свойством. Однако после нахождения элемента с данным свойством в однонаправленном списке у нас нет возможности получить удобный и быстрый способ доступа к предыдущему элементу.

Для устранения этого неудобства добавим в каждое звено списка еще одно поле, значением которого будет ссылка на предыдущее звено.

Type ukazat= ^S; 
S= record 
Inf: integer; 
Next: ukazat; 
Pred: ukazat; 
End;
Динамическая структура, состоящая из звеньев такого типа, называется двунаправленным списком, который схематично можно изобразить так:



Наличие в каждом звене двунаправленного списка ссылки как на следующее, так и на предыдущее звено позволяет от каждого звена двигаться по списку в любом направлении. По аналогии с однонаправленным списком здесь есть заглавное звено. В поле Pred этого звена фигурирует пустая ссылка nil, свидетельствующая, что у заглавного звена нет предыдущего (так же, как у последнего нет следующего).

В программировании двунаправленные списки часто обобщают следующим образом: в качестве значения поля Next последнего звена принимают ссылку на заглавное звено, а в качестве значения поля Pred заглавного звена – ссылку на последнее звено:



Как видно, здесь список замыкается в своеобразное «кольцо»: двигаясь по ссылкам, можно от последнего звена переходить к заглавному звену, а при движении в обратном направлении – от заглавного звена переходить к последнему. Списки подобного рода называют кольцевыми списками.